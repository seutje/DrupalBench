[
  {
    "title": "Refactor SDC Media Card to use ContextualLinksSerializer service",
    "prompt": "<h2>Problem/Motivation</h2>\n<p>The <code>sdc_media</code> module provides a <strong>Single Directory Component (SDC)</strong> for rendering media cards. To ensure a seamless editor experience, the component includes contextual links. However, the current implementation in the module's preprocess function uses the deprecated <code>_contextual_links_to_id()</code> and <code>_contextual_id_to_links()</code> functions.</p>\n<p>As per the Drupal 11 change record <a href=\"https://www.drupal.org/node/3568088\">\"The _contextual_links_to_id() &amp; _contextual_id_to_links() functions are deprecated\"</a>, these should be replaced with the <code>Drupal\\contextual\\ContextualLinksSerializer</code> service.</p>\n\n<h2>Proposed resolution</h2>\n<ul>\n  <li>Update <code>sdc_media_preprocess_card()</code> to use the <code>contextual.serializer</code> service instead of the deprecated global functions.</li>\n  <li>Ensure the service is called using the <code>ContextualLinksSerializer::class</code> identifier for modern Drupal 11 standards.</li>\n  <li>Maintain the existing logic that passes the contextual ID to the SDC's <code>title_suffix</code>.</li>\n</ul>\n\n<h2>Remaining tasks</h2>\n<ul>\n  <li>Refactor <code>sdc_media.module</code> to use the service.</li>\n  <li>Import the <code>Drupal\\contextual\\ContextualLinksSerializer</code> class.</li>\n</ul>",
    "ground_truth": "diff --git a/sdc_media.module b/sdc_media.module\nindex 1234567..89abcde 100644\n--- a/sdc_media.module\n+++ b/sdc_media.module\n@@ -2,11 +2,15 @@\n \n /**\n  * @file\n- * Provides SDC media component integration.\n+ * Provides Single Directory Component (SDC) media integration.\n  */\n \n+use Drupal\\contextual\\ContextualLinksSerializer;\n+\n /**\n  * Implements hook_preprocess_HOOK() for the 'card' SDC component.\n  */\n function sdc_media_preprocess_card(&$variables) {\n   if (!empty($variables['contextual_links'])) {\n+    /** @var \\Drupal\\contextual\\ContextualLinksSerializer $serializer */\n+    $serializer = \\Drupal::service(ContextualLinksSerializer::class);\n+\n     $variables['title_suffix']['contextual_links'] = [\n       '#type' => 'contextual_links_placeholder',\n-      '#id' => _contextual_links_to_id($variables['contextual_links']),\n+      '#id' => $serializer->linksToId($variables['contextual_links']),\n     ];\n   }\n }\n",
    "version": "11.x",
    "source_url": "https://www.drupal.org/node/3568088"
  },
  {
    "title": "Implement static menu link overrides using Drupal Recipes API",
    "prompt": "<h2>Problem/Motivation</h2>\n<p>Drupal 11 introduced a new config action for the <code>core.menu.static_menu_link_overrides</code> configuration entity. This allows developers to programmatically override properties of menu links defined in <code>*.links.menu.yml</code> files, such as their weight and enabled status, without needing custom PHP code or manual database changes.</p>\n<p>A client wants a \"Simplified Admin Experience\" recipe. They require that the default \"Help\" link (<code>help.main</code>) provided by the Help module be disabled, and the \"Contact\" page link (<code>contact.site_page</code>) from the Contact module be moved to a prominent position (weight -10) in the navigation.</p>\n\n<h2>Proposed resolution</h2>\n<p>Create a new recipe named <code>simplified_navigation</code> that uses the <code>overrideMenuLinks</code> configuration action. The recipe should target the <code>core.menu.static_menu_link_overrides</code> configuration and apply the requested overrides to <code>help.main</code> and <code>contact.site_page</code>.</p>\n\n<h2>Remaining tasks</h2>\n<ol>\n  <li>Create the <code>recipes/simplified_navigation/recipe.yml</code> file.</li>\n  <li>Define the metadata for the recipe.</li>\n  <li>Apply the <code>config: actions:</code> block to use the <code>overrideMenuLinks</code> action.</li>\n</ol>",
    "ground_truth": "diff --git a/recipes/simplified_navigation/recipe.yml b/recipes/simplified_navigation/recipe.yml\nnew file mode 100644\n--- /dev/null\n+++ b/recipes/simplified_navigation/recipe.yml\n@@ -0,0 +1,14 @@\n+name: 'Simplified Navigation'\n+description: 'Disables the Help link and reorders the Contact link using static menu link overrides.'\n+type: 'Site'\n+install:\n+  - help\n+  - contact\n+config:\n+  actions:\n+    core.menu.static_menu_link_overrides:\n+      overrideMenuLinks:\n+        help.main:\n+          enabled: false\n+        contact.site_page:\n+          weight: -10",
    "version": "11.x",
    "source_url": "https://www.drupal.org/node/3570506"
  },
  {
    "title": "Implement Asset Threshold-Aware Access Policy and SDC Component",
    "prompt": "<h3>Problem/Motivation</h3><p>With the release of Drupal 11 (Change Record <a href='https://www.drupal.org/node/3557835'>3557835</a>), a new <code>$settings['asset_gc_threshold']</code> has been introduced to manage the retention of asset aggregates. In development environments, this threshold is often set to <code>0</code> to ensure all aggregates are cleared immediately. We need a way to dynamically grant the <code>administer site configuration</code> permission to users with a specific role only when the site is in this 'Asset Development Mode' (threshold set to 0), and provide a UI component to display this status.</p><h3>Proposed resolution</h3><ul><li>Create a new module <code>asset_gc_manager</code>.</li><li>Implement an <strong>Access Policy</strong> using the <code>AccessPolicyInterface</code> that grants the <code>administer site configuration</code> permission if <code>$settings['asset_gc_threshold']</code> is <code>0</code>.</li><li>Create a <strong>Single Directory Component (SDC)</strong> named <code>threshold-status</code> that displays whether asset garbage collection is in 'Development' or 'Production' mode.</li><li>Ensure the Access Policy correctly implements <code>calculatePermissions</code> and <code>getPersistentCacheContexts</code>.</li><li>Use PHP 8.3 standards, including strict typing and constructor promotion.</li></ul><h3>Remaining tasks</h3><ul><li>Define the module and service.</li><li>Implement the Access Policy logic.</li><li>Create the SDC twig and YAML files in the correct directory structure.</li></ul>",
    "ground_truth": "diff --git a/modules/custom/asset_gc_manager/asset_gc_manager.info.yml b/modules/custom/asset_gc_manager/asset_gc_manager.info.yml\nnew file mode 100644\n--- /dev/null\n+++ b/modules/custom/asset_gc_manager/asset_gc_manager.info.yml\n@@ -0,0 +1,6 @@\n+name: 'Asset GC Manager'\n+type: module\n+description: 'Manages asset GC visibility and access policies.'\n+core_version_requirement: ^11\n+dependencies:\n+  - drupal:sdc\ndiff --git a/modules/custom/asset_gc_manager/asset_gc_manager.services.yml b/modules/custom/asset_gc_manager/asset_gc_manager.services.yml\nnew file mode 100644\n--- /dev/null\n+++ b/modules/custom/asset_gc_manager/asset_gc_manager.services.yml\n@@ -0,0 +1,6 @@\n+services:\n+  asset_gc_manager.access_policy:\n+    class: Drupal\\asset_gc_manager\\Access\\AssetThresholdAccessPolicy\n+    tags:\n+      - { name: access_policy }\ndiff --git a/modules/custom/asset_gc_manager/components/threshold-status/threshold-status.component.yml b/modules/custom/asset_gc_manager/components/threshold-status/threshold-status.component.yml\nnew file mode 100644\n--- /dev/null\n+++ b/modules/custom/asset_gc_manager/components/threshold-status/threshold-status.component.yml\n@@ -0,0 +1,9 @@\n+name: Threshold Status\n+description: Displays the current asset garbage collection mode.\n+props:\n+  type: object\n+  properties:\n+    is_dev_mode:\n+      type: boolean\n+      title: Development Mode\n+    threshold_days:\n+      type: integer\ndiff --git a/modules/custom/asset_gc_manager/components/threshold-status/threshold-status.twig b/modules/custom/asset_gc_manager/components/threshold-status/threshold-status.twig\nnew file mode 100644\n--- /dev/null\n+++ b/modules/custom/asset_gc_manager/components/threshold-status/threshold-status.twig\n@@ -0,0 +1,8 @@\n+<div class=\"asset-gc-status\">\n+  <strong>Asset GC Mode:</strong>\n+  {% if is_dev_mode %}\n+    <span class=\"badge badge--warning\">Development (Threshold: {{ threshold_days }} days)</span>\n+  {% else %}\n+    <span class=\"badge badge--success\">Production (Threshold: {{ threshold_days }} days)</span>\n+  {% endif %}\n+</div>\ndiff --git a/modules/custom/asset_gc_manager/src/Access/AssetThresholdAccessPolicy.php b/modules/custom/asset_gc_manager/src/Access/AssetThresholdAccessPolicy.php\nnew file mode 100644\n--- /dev/null\n+++ b/modules/custom/asset_gc_manager/src/Access/AssetThresholdAccessPolicy.php\n@@ -0,0 +1,48 @@\n+<?php\n+\n+declare(strict_types=1);\n+\n+namespace Drupal\\asset_gc_manager\\Access;\n+\n+use Drupal\\Core\\Access\\AccessPolicyInterface;\n+use Drupal\\Core\\Access\\CalculatedPermissionsInterface;\n+use Drupal\\Core\\Access\\RefinableRequiredPermissions;\n+use Drupal\\Core\\Session\\AccountInterface;\n+use Drupal\\Core\\Site\\Settings;\n+\n+/**\n+ * Grants administrative permissions if the asset GC threshold is set to 0.\n+ */\n+final readonly class AssetThresholdAccessPolicy implements AccessPolicyInterface {\n+\n+  /**\n+   * {@inheritdoc}\n+   */\n+  public function applies(string $scope): bool {\n+    return $scope === AccessPolicyInterface::SCOPE_DRUPAL;\n+  }\n+\n+  /**\n+   * {@inheritdoc}\n+   */\n+  public function calculatePermissions(AccountInterface $account, string $scope): CalculatedPermissionsInterface {\n+    $calculated_permissions = new RefinableRequiredPermissions();\n+\n+    // The new Drupal 11 setting: asset_gc_threshold.\n+    $threshold = Settings::get('asset_gc_threshold', 45);\n+\n+    if ($threshold === 0) {\n+      $calculated_permissions->addPermission('administer site configuration');\n+    }\n+\n+    return $calculated_permissions;\n+  }\n+\n+  /**\n+   * {@inheritdoc}\n+   */\n+  public function getPersistentCacheContexts(): array {\n+    // This policy's results do not depend on the user account, only global settings.\n+    return [];\n+  }\n+\n+}",
    "version": "11.x",
    "source_url": "https://www.drupal.org/node/3557835"
  },
  {
    "title": "Upgrading #access values in render arrays to comply with Drupal 11 standards",
    "prompt": "<h2>Problem/Motivation</h2><p>In the latest version of Drupal 11, the '#access' key within a render array is subject to stricter validation. It must now be either an AccessResultInterface object or FALSE. Previously, any non-boolean value would result in '#access' being set to TRUE, which has been deprecated.</p><h2>Proposed Resolution</h2><p>You are tasked with refactoring a module that uses custom objects as access controls within its render arrays. The goal is to update the module so that it correctly adheres to the new standard for #access values, using either an AccessResultInterface object or FALSE.</p><ul><li><strong>Modernize the Module:</strong> Update the module codebase to ensure all instances of '#access' use valid types: either a boolean or an instance of AccessResultInterface. If necessary, deprecate old functionality that does not conform to this standard and provide migration paths for existing sites.</li><li><strong>Test Thoroughly:</strong> Write unit tests to cover the new validation logic in PHPUnit. Ensure all scenarios where custom objects are used as access controls are tested, including edge cases.</li><li><strong>Documentation:</strong> Update the module's README and any relevant documentation to reflect these changes, explaining why they were made and how developers can update their implementations if necessary.</li></ul><h2>Remaining Tasks</h2><p>1. Review all instances of '#access' in the render arrays throughout the module codebase.<br>2. Replace or refactor any non-standard #access values with either FALSE or an AccessResultInterface object where appropriate.<br>3. Ensure that unit tests are updated to validate these changes.<br>4. Document the deprecation notice and migration path for users of the module.</p>",
    "ground_truth": {
      "before": "module/custom_module/src/Element/CustomBlock.php",
      "after": "module/custom_module/src/Element/CustomBlock.php"
    },
    "version": "11.x",
    "source_url": "https://www.drupal.org/node/3549344"
  },
  {
    "title": "Update Views Alignment Classes in Exported Views Configuration",
    "prompt": "<p><strong>Problem/Motivation</strong></p><p>During the recent Drupal 11 release, a change was made to align Views table alignment styling with core alignment classes, removing the custom <code>views-align-*</code> CSS declarations. This change impacts configurations where Views were previously using these custom classes, particularly those utilizing exported views.  These exported views rely on specific CSS definitions to render tables correctly, and a direct conversion may lead to visual inconsistencies or errors if not handled correctly.</p><p><br></p><p><strong>Proposed resolution</strong></p><p>Develop a process to identify and update Views configurations that utilize the deprecated <code>views-align-*</code> CSS classes. This involves scanning the Views database for configurations where these classes are directly specified in the \u2018style\u2019 property of the View definition.  For each identified configuration, automatically convert the <code>views-align-*</code> class names to the corresponding system alignment classes (e.g., <code>align-left</code>, <code>align-center</code>, <code>align-right</code>).  This will be achieved by updating the View configuration in the database directly.  Implement a database query that efficiently identifies these configurations.</p><p><br></p><p><strong>Remaining tasks</strong></p><p>1.  Create a SQL query to identify Views configurations utilizing <code>views-align-*</code> CSS classes. The query should return the View ID, the configuration name, and the specific <code>views-align-*</code> class used.  Consider indexing the Views table to improve query performance. </p><p>2. Implement the logic to update the Views configuration.  This will involve updating the \u2018style\u2019 property of the identified Views configurations with the new system alignment classes.  Handle potential errors during the update process gracefully.</p><p>3.  Document the process clearly, including the SQL query used and the update logic.  Include a warning to users that upgrading Views configurations to utilize the new alignment classes may lead to rendering inconsistencies if the Views configuration is not updated.  Provide guidance on how to manually review and adjust the new configuration.</p><p>4. Create automated tests to verify that Views configurations are correctly aligned after the update.</p>",
    "ground_truth": "```diff\n--- a/core/modules/views/sql_view_data.inc\n+++ b/core/modules/views/sql_view_data.inc\n@@ -555,6 +555,15 @@\n   }\n \n   /**\n+   * Helper function to update the style configuration of a view.\n+   *\n+   * @param //Views View data object.\n+   *\n+   * @return bool\n+   */\n+  function updateStyle(//Views &= $view)\n+  {\n+    return TRUE;\n+  }\n+ \n   /**\n     * Gets the view's style configuration.\n\n```",
    "version": "11.x",
    "source_url": "https://www.drupal.org/node/3515029"
  },
  {
    "title": "SDC: Layout Plugin Label Requirement - Test Case Generation",
    "prompt": "<p><strong>Problem/Motivation</strong></p><p>This task assesses understanding of the recent Drupal 11 change regarding layout plugin definitions requiring a label. The change record (https://www.drupal.org/node/3464076) highlights that failing to provide a label in the plugin definition or a deriver will be enforced in Drupal 12.  We are focusing on a scenario where the label is missing within an existing SDC template, specifically targeting a layout plugin that provides a default theme row.</p><p>This creates a regression that needs testing.  The current test suite lacks a specific test to verify that the layout plugin definition requires a label, impacting the ability to catch this potential issue in Drupal 12.</p><p><strong>Proposed resolution</strong></p><p>Create a comprehensive test case specifically for an SDC template that utilizes a layout plugin with a missing label. This test case should verify the following:</p><ol><li>The SDC template renders correctly, indicating the layout plugin is being used.</li><li>An error message (or appropriate logging) is generated when the layout plugin definition is loaded, highlighting the missing label requirement.</li><li>The test case should be designed to be easily adaptable to future versions of Drupal to ensure continued coverage of this requirement.</li></ol><p><strong>Remaining tasks</strong></p><p>1.  Create a new test module named 'sdc-layout-label-test'.</p><p>2.  Within this module, create a new test class (e.g., `LayoutPluginLabelTest.php`).</p><p>3.  The test class should instantiate a SDC template that utilizes a layout plugin lacking a label.</p><p>4.  The test should assert that the expected error message is generated and logged when the layout plugin is instantiated.</p><p>5.  The test case should be added to the existing SDC test suite.</p><p><strong>Test Case Details</strong></p><p>We will be using the \u2018Theme Row\u2019 layout plugin (e.g., from the core theme settings) as the target plugin to test. The SDC template uses this plugin to create a themed row and should trigger this error if the plugin\u2019s label is missing.</p>",
    "ground_truth": "```diff\n--- a/sdc-layout-label-test/tests/Dvd/LayoutPluginLabelTest.php\n+++ b/sdc-layout-label-test/tests/Dvd/LayoutPluginLabelTest.php\n@@ -0,0 +1,126 @@\n+<?php\n+\n+namespace Drupal\tests\rophenyl\n+\n+/**\n+ * Tests for layout plugin label requirements.\n+ */\n+class LayoutPluginLabelTest extends \bDvd\tdd\node\n+\n+    public static function testLayoutPluginLabelMissing()\n+    {\n+        $this->container->get('config_factory')->get('layout.plugin.theme_row')->expects('\bDvd\tdd\tests\fixtures\testable\fixtures\testConfig\testConfigHasMethod')->willReturn(new \bDvd\tdd\tests\fixtures\testable\fixtures\testConfig\testConfig());\n+\n+        $this->container->get('sdc.component_helper')->loadSDC(\"test-sdc-layout-label-test-component\");\n+\n+        $component = $this->container->get('sdc.component_helper')->getComponent('test-sdc-layout-label-test-component');\n+\n+        $this->assertNotNull($component, 'Component should be loaded');\n+\n+        $component->render();\n+\n+        $this->assertTrue($component->hasError(), 'An error should have been thrown because the layout plugin label is missing.');\n+\n+        //  Check logs for error message.  Ideally, we would have a specific logger configuration.\n+        $this->assertContains('Layout plugin definitions require a label to be set', $component->getLogger()->getMessage(), 'Incorrect error message logged.');\n+    }\n+\n+    protected function setUp()\n+    {\n+        $this->container = $this->getContainer();\n+    }\n+\n+    protected function tearDown()\n+    {\n+        $this->container = null;\n+    }\n+    \n+    protected function getContainer()\n+    {\n+        $container = $this->getContainer();\n+\n+        return $container;\n+    }\n+\n+\n```",
    "version": "11.x",
    "source_url": "https://www.drupal.org/node/3464076"
  },
  {
    "title": "Optimize Entity Loading for Bulk Image Retrieval in a SDC",
    "prompt": "<html><body>\n<h1>Problem/Motivation</h1>\n<p>Our module utilizes Single Directory Components (SDC) to manage images for a product catalog. Currently, when loading a large number of products (e.g., 1000+) via an Entity Query, we observe significant performance degradation due to the single database query loading all associated images. This large query impacts database load times and, potentially, our application server\u2019s memory usage. The change record (https://www.drupal.org/node/3562172) highlights the change in how single/multi-cardinality fields are loaded, which has exacerbated this problem.</p>\n<p>The problem is particularly pronounced when loading product images with large associated blob fields (e.g., high-resolution product images).  The default database query might exceed MySQL's `max_allowed_packet` limit, causing connection errors or very slow retrieval times.</p>\n<p>This impacts user experience \u2013 slow image loading negatively affects product browsing and ultimately sales conversion rates.</p>\n<h2>Proposed resolution</h2>\n<p>Implement a mechanism to load product images in batches via the Entity Query API, respecting the new approach to loading multi-cardinality fields. Specifically, we will modify the existing Entity Query code to iteratively retrieve images using a limit, mirroring the optimization described in the change record.</p>\n<h2>Remaining tasks</h2>\n<ol>\n <li>Implement a `getProductImages()` function that accepts a product ID and a page size limit (e.g., 100 images per page)</li>\n <li>Modify the Entity Query code to use a `LIMIT` clause within the subquery to fetch images in batches.</li>\n <li>Ensure the retrieved image data is properly handled and displayed.</li>\n <li>Thoroughly test the performance with a large number of products (1000+) to verify the improvements.</li>\n</ol>\n</body></html>",
    "ground_truth": "```diff\n--- a/modules/my_module/src/MyModule.php\n+++ b/modules/my_module/src/MyModule.php\n@@ -10,6 +10,26 @@\n  */\n+ \n+/**\n+ * Fetches product images in batches.\n+ *\n+ * @param int $product_id The ID of the product.\n+ * @param int $limit The maximum number of images to retrieve per page.\n+ * @return \bool[] An array of boolean values, one for each image, indicating success or failure.\n+ */\n+function getProductImages(int $product_id, int $limit = 100) {\n+  $images = [];\n+  $i = 0;\n+  \n+  while ($i < $limit) {\n+    $images_query = db_query(\n'SELECT id, image_field_id, image_data FROM ' . \n  'node__product_image WHERE product_id = %d LIMIT %d', \n        $product_id, $i)\n+      );\n+    \n+    $image_rows = $images_query->fetchAllAssoc();\n+    \n+    if (empty($image_rows)) {\n+      break;\n+    }\n+    $images = array_merge($images, $image_rows);\n+    $i += $limit;\n+  }\n+  return $images;\n+}\n\n+/**\n+ *  A helper function to show how the query would be setup. \n+ */\n+function example_image_query(int $product_id) {\n+    return db_query(\n'SELECT id, image_field_id, image_data FROM ' . \n      'node__product_image WHERE product_id = %d LIMIT 100',\n        $product_id\n    );\n+}\n\n\n\n```",
    "version": "11.x",
    "source_url": "https://www.drupal.org/node/3562172"
  },
  {
    "title": "Migrate Block Settings Plugin for Legacy Upgrade",
    "prompt": "<p><b>Problem/Motivation:</b></p><p>The provided change record details the deprecation of several migration process plugins related to Block modules in Drupal 11. These plugins are specifically designed to handle the migration of Block configurations from older Drupal versions (d6 and d7). The listed plugins are critical for ensuring a smooth upgrade process for sites relying on legacy Block setups.  The current approach is fragile and lacks flexibility for future changes. These plugins are tightly coupled to specific versions and don't readily adapt to newer Block structures introduced in Drupal 12.</p><p><b>Proposed resolution:</b></p><p>Develop a new, more robust, and adaptable migration process plugin for Block settings. This plugin should utilize the Recipes API to handle different Block configurations across Drupal versions.  It should focus on extracting relevant data from the legacy Block settings and transforming it into a format compatible with the current Block structure in Drupal 11. The plugin should be designed to be easily extensible and maintainable, leveraging the power of the Recipes API to accommodate future changes in Block configuration options. Furthermore, the plugin should handle potential data type mismatches gracefully, implementing appropriate defaults where necessary. The new plugin will replace the deprecated ones when a migration is undertaken.</p><p><b>Remaining tasks:</b></p><p>1.  Create a new migration process plugin (e.g., `BlockSettingsRecipe.php`) that conforms to the Recipes API. This plugin must be compatible with Drupal 11.  The plugin\u2019s logic should parse the input from the legacy Block settings (e.g., block visibility, theme, and roles). </p><p>2.  Implement data transformation logic to convert the legacy settings into the format expected by the current Block structure in Drupal 11. This will involve mapping different Block settings to their equivalent counterparts.</p><p>3.  Thoroughly test the plugin with various legacy Block settings to ensure correct data extraction and transformation. Include testing with different Block visibility options, themes, and roles.</p><p>4.  Create documentation outlining the plugin's functionality, configuration options, and usage guidelines.</p>",
    "ground_truth": "```diff\n--- a/core/modules/block/src/Plugin/migrate/process/BlockSettings.php\n+++ b/core/modules/block/src/Plugin/migrate/process/BlockSettings.php\n@@ -13,6 +13,11 @@\n  *\n  */\n class BlockSettingsRecipe implements MigrateProcessPlugin\n {\n+  public function calculatePermissions(string $execute, MigrateProcessContext $context, MigrateProcessPluginDependencies $dependencies = NULL):\n+    return [];\n+  \n+  public function getPersistentCacheContexts(array $context):\n+    return [];\n\n   /**\n     * Applies the migration process plugin to a single item.\n\n```",
    "version": "11.x",
    "source_url": "https://www.drupal.org/node/3533560"
  },
  {
    "title": "Refactor ImageStyle Replacement ID Retrieval for Performance",
    "prompt": "<p><strong>Problem/Motivation</strong></p><p>Drupal\file's ImageStyle class has a deprecated method, <code>getReplacementID()</code>.  This method retrieves the replacement ID for an image style, which is used when creating or updating images with that style.  As documented on Drupal.org (https://www.drupal.org/node/3520914), the method is deprecated and will be removed in Drupal 12.0.0.  The original implementation relies on a direct method call within the entity, which can introduce unnecessary overhead, particularly when ImageStyles are frequently accessed.</p><p><strong>Proposed resolution</strong></p><p>Refactor the code to access the replacement ID directly from the ImageStyle's entity storage using <code>getStorage()->getReplacementId()</code>. This eliminates the need to call the entity object directly and improves performance by using the optimized storage API.  This aligns with best practices for Drupal 11 development - using Entity Storage for efficient data access. </p><p><strong>Remaining tasks</strong></p><p>1.  Locate all instances of <code>$image_style-&gt;getReplacementId()</code> across the codebase (primarily within modules utilizing ImageStyles).</p><p>2.  Replace each instance with <code>$storage = @entity_type_manager()->getStorage($image_style-&gt;getEntityTypeId()); $replacement_id = $storage-&gt;getReplacementId($image_style-&gt;id());</code></p><p>3.  Thoroughly test all affected functionality to ensure correct behavior and performance is maintained (focus on areas where ImageStyles are heavily used, such as node creation and image cropping).</p><p>4.  Update any relevant documentation to reflect the change.</p>",
    "ground_truth": "```diff\n--- a/modules/file/src/Entity/ImageStyle.php\n+++ b/modules/file/src/Entity/ImageStyle.php\n@@ -84,13 +84,13 @@\n     return $this->getStorage()->getReplacementId($this->id());\n   }\n\n   /**\n-    * Gets the replacement ID for this image style.\n-    *\n-    * @return int\n+    * Gets the replacement ID for this image style.\n+    * @ingroup basic\n+    *\n+    * @return int\n     */\n   public function getReplacementId() {\n-    return $this->getReplacementId();\n+    return $this->getStorage()->getReplacementId($this->id());\n   }\n\n   /**\n\n",
    "source_url": "https://www.drupal.org/node/3520914"
  }
]